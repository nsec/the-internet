#!/usr/bin/python3

import argparse
import csv
import lxc
import math
import netaddr
import os
import random
import shutil
import sqlite3
import subprocess
import sys
import webbrowser


class InternetDB():
    def __init__(self, project_path):
        self.con = sqlite3.connect(':memory:')
        self.project_path = project_path

    def init_tables(self, level):
        cur = self.con.cursor()
        cur.execute("DROP TABLE IF EXISTS router")
        cur.execute("CREATE TABLE router (id INT, name TEXT, gps TEXT, "
                    "fqdn TEXT, lxcname TEXT, asn INT, internal INT, "
                    "tier INT, prefix TEXT)")
        self.read_routers_csv(cur, level)

        cur.execute("DROP TABLE IF EXISTS links")
        cur.execute("CREATE TABLE links (id INT, left TEXT, right TEXT, "
                    "mac_left TEXT, mac_right TEXT, left_prio INT, "
                    "right_prio INT, latency REAL, speed INT)")
        self.import_links_csv(cur)

        cur.execute("DROP TABLE IF EXISTS dns")
        cur.execute("CREATE TABLE dns (ipv6 TEXT, name TEXT)")
        self.import_dns_csv(cur)

    def dist_latency(self, origin, destination):
        o = origin.split("/")
        lat1 = float(o[0])
        lon1 = float(o[1])
        d = destination.split("/")
        lat2 = float(d[0])
        lon2 = float(d[1])
        # km
        radius = 6371

        dlat = math.radians(lat2 - lat1)
        dlon = math.radians(lon2 - lon1)
        a = math.sin(dlat / 2) * math.sin(dlat / 2) + \
            math.cos(math.radians(lat1)) *\
            math.cos(math.radians(lat2)) * \
            math.sin(dlon / 2) * math.sin(dlon / 2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
        d = radius * c
        # speed of light in optical fiber approx 213 km/s
        # adding 35% for the overhead
        # adding 0.5ms for the transceiver delay
        speed = 139
        return round(d/speed + 0.5, 1)

    def import_links_csv(self, cur):
        with open(os.path.join(self.project_path, "Links.csv"),
                  'r') as csvfile:
            reader = csv.reader(csvfile)
            first = 1
            linkid = 0
            for row in reader:
                # skip first line
                if first == 1:
                    first = 0
                    continue

                # skip empty lines
                if not row[0]:
                    continue

                left = get_router_data(cur, row[0])
                if not left:
                    continue

                right = get_router_data(cur, row[1])
                if not right:
                    continue

                latency = self.dist_latency(left["gps"], right["gps"])

                # csv: Left, Right, Mac Left, Mac Right, Left priority,
                #      Right priority, Speed

                # db: id, left, right, mac_left, mac_right, left_prio,
                #     right_prio, latency, speed
                cur.execute("INSERT INTO links VALUES(?,?,?,?,?,?,?,?,?)",
                            (linkid, row[0], row[1], row[2], row[3], row[4],
                             row[5], latency, row[6]))
                linkid += 1

    def read_routers_csv(self, cur, level):
        routerid = 0
        with open(os.path.join(self.project_path, "Telco.csv"),
                  'r') as csvfile:
            reader = csv.reader(csvfile)
            first = 1
            for row in reader:
                # skip first line
                if first == 1:
                    first = 0
                    continue

                # skip empty lines
                if not row[0]:
                    continue

                if row[8] and level is not None and int(row[8]) > level:
                    continue

                # csv: Name-0, FQDN-1, Lxc-name-2, Tier-3, Prefix-4, ASN-5,
                #      Internal-6, GPS-7

                # db: id, name, gps, fqdn, lxcname, asn, internal, tier, prefix
                cur.execute("INSERT INTO router VALUES(?,?,?,?,?,?,?,?,?)",
                            (routerid, row[0], row[7], row[1], row[2], row[5],
                             row[6], row[3], row[4]))
                routerid += 1

        with open(os.path.join(self.project_path, "Routers.csv"),
                  'r') as csvfile:
            reader = csv.reader(csvfile)
            first = 1
            for row in reader:
                # skip first line
                if first == 1:
                    first = 0
                    continue

                # skip empty lines
                if not row[0]:
                    continue

                # csv: Name-0, Country-1, GPS-2, Prefix-3, FQDN-4, Subnet-5
                #      Lxc-name-6

                # db: id, name, gps, fqdn, lxcname, uplink, asn, internal,
                #     tier, prefix
                cur.execute("INSERT INTO router VALUES(?,?,?,?,?,?,?,?,?,?)",
                            (routerid, row[0], row[2], row[4], row[6], "",
                             0, 4, row[5], row[9]))
                routerid += 1

    def import_dns_csv(self, cur):
        with open(os.path.join(self.project_path, "DNS.csv"), 'r') as csvfile:
            reader = csv.reader(csvfile)
            first = 1
            for row in reader:
                # skip first line
                if first == 1:
                    first = 0
                    continue

                # skip lines with empty or invalid fields
                if not row[0] or not row[1] or row[1][0] == "(":
                    continue

                # csv: ipv6-0, name-1, lxc-name-2
                # db: ipv6, name
                cur.execute("INSERT INTO dns VALUES(?,?)",
                            (row[0].strip(), row[1].strip()))


class Error(Exception):
    pass


def gen_interfaces(cur, rtrlxcname, rtrid, rtrprefix,
                   rtrtier, rtrfqdn, target):
    os.mkdir("%s/%s/etc/network/" % (target, rtrlxcname))
    random.seed(rtrid)
    ip = netaddr.ip
    strprefix = "%s:%s:%s:%s:%s:%s" % (
        rtrprefix, "dead:beef", random.randint(0, 4095),
        random.randint(0, 4095), random.randint(0, 4095),
        random.randint(0, 4095))
    ipv6 = str(ip.IPAddress(strprefix).ipv6())

    with open("%s/%s/etc/network/interfaces" %
              (target, rtrlxcname), "w") as fd:
        fd.write("""auto lo
iface lo inet loopback
    post-up ip -6 addr add dev lo %s/128
    post-up echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
""" % (ipv6))

        for link in get_links(cur, rtrlxcname, True):
            fd.write("""    post-up tc qdisc add dev %s root netem """
                     """delay %sms || true\n""" %
                     (link['iface'], link['latency']))
            fd.write("""    post-up tc qdisc add dev %s root netem """
                     """rate %smbit || true\n""" %
                     (link['iface'], link['speed']))
        if rtrtier != 3:
            return

        for link in get_links(cur, rtrlxcname, True):
            if not link['right_prefix']:
                print("Missing peer for link: %s", link['id'])

            if link['right_tier'] == 4:
                a = netaddr.EUI(link['mac_right'])
                fd.write("""
auto %s
iface %s inet6 manual
    post-up ip -6 route add dev %s %s via %s
""" % (
                    link['iface'], link['iface'], link['iface'],
                    link['right_prefix'], a.ipv6_link_local()))


def gen_zebra(rtrlxcname, target):
    os.mkdir("%s/%s/etc/quagga/" % (target, rtrlxcname))
    with open("%s/%s/etc/quagga/zebra.conf" % (target, rtrlxcname), "w") as fd:
        fd.write("""hostname %s
password zebra%s
enable password zebra%s\n""" % (rtrlxcname, random.randint(9999, 99999999),
                                random.randint(9999, 99999999)))


def get_router_data(cur, name):
    rtr = {}
    cur.execute("select id, name, gps, fqdn, lxcname, asn, internal, tier, "
                "prefix from router where lxcname=:name", {"name": name})
    r = cur.fetchone()
    if not r:
        return None
    rtr["id"], rtr["name"], rtr["gps"], rtr["fqdn"], rtr["lxcname"], \
        rtr["asn"], rtr["internal"], rtr["tier"], rtr["prefix"] = r
    return rtr


def get_links(cur, rtrlxcname, show_all=False):
    linklist = []
    cur.execute("select id,left,right,mac_left,mac_right,left_prio,"
                "right_prio,latency,speed from links where left=:name",
                {"name": rtrlxcname})
    for l in cur.fetchall():
        link = {}
        link["id"], link["left"], link["right"], link["mac_left"], \
            link["mac_right"], link["left_prio"], link["right_prio"], \
            link["latency"], link["speed"] = l
        r = get_router_data(cur, link["right"])
        if r["asn"] != "" or show_all:
            link["right_asn"] = r["asn"]
            link["right_tier"] = r["tier"]
            link["right_prefix"] = r["prefix"]
            link["iface"] = "veth-%s-1" % link["id"]
            linklist.append(link)

    cur.execute("select id,right,left,mac_right,mac_left,right_prio,"
                "left_prio,latency,speed from links where right=:name",
                {"name": rtrlxcname})
    for l in cur.fetchall():
        link = {}
        link["id"], link["right"], link["left"], link["mac_left"], \
            link["mac_right"], link["left_prio"], link["right_prio"], \
            link["latency"], link["speed"] = l
        r = get_router_data(cur, link["left"])
        if r["asn"] != "" or show_all:
            link["right_asn"] = r["asn"]
            link["right_tier"] = r["tier"]
            link["right_prefix"] = r["prefix"]
            link["iface"] = "veth-%s-2" % link["id"]
            linklist.append(link)

    return sorted(linklist, key=lambda link: link['id'])


def gen_bgpd(cur, rtrlxcname, rtrid, rtrasn, target):
    linklist = get_links(cur, rtrlxcname)
    ip = netaddr.ip
    rtridv4 = str(ip.IPAddress(rtrid).ipv4())
    if rtridv4 == "0.0.0.0":
        rtridv4 = "123.123.123.123"

    with open("%s/%s/etc/quagga/bgpd.conf" % (target, rtrlxcname), "w") as fd:
        fd.write("""hostname %s
password zebra%s

router bgp %s
 bgp router-id %s
 no bgp default ipv4-unicast\n""" % (rtrlxcname,
                                     random.randint(9999, 99999999),
                                     rtrasn, rtridv4))
        weight = 10
        for l in linklist:
            mac = netaddr.EUI(l["mac_right"])
            ll = str(mac.ipv6_link_local())
            l["link-local"] = ll
            fd.write(" neighbor %s remote-as %s\n" % (ll, l["right_asn"]))
            fd.write("! neighbor %s weight %s\n" % (ll, weight))
            fd.write(" neighbor %s interface %s\n\n" % (ll, l["iface"]))
            weight += 10
        fd.write(" address-family ipv6\n")
        for l in linklist:
            fd.write("  neighbor %s activate\n" % l["link-local"])
        fd.write("  redistribute connected\n")
        fd.write("  redistribute kernel\n")
        fd.write(" exit-address-family\n")


def gen_hosts(rtrlxcname, target):
    with open("%s/%s/etc/hosts" % (target, rtrlxcname), "w") as fd:
        fd.write("""127.0.0.1    localhost
127.0.1.1    %s

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback localhost
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters\n""" % rtrlxcname)


def gen_hostname(rtrlxcname, target):
    with open("%s/%s/etc/hostname" % (target, rtrlxcname), "w") as fd:
        fd.write("%s\n" % rtrlxcname)


def gen_lxc_config(cur, rtrlxcname, target):
    with open("%s/%s/config" % (target, rtrlxcname), "w+") as fd:
        fd.write("""# Auto-generated, do not manually edit.

# Distribution configuration
lxc.include = /usr/share/lxc/config/ubuntu.common.conf
lxc.include = /usr/share/lxc/config/ubuntu.userns.conf
lxc.arch = amd64

# Container specific configuration
lxc.rootfs = overlayfs:/var/lib/lxc/tpl-router/rootfs:/internet/%s/overlay/
lxc.utsname = %s

""" % (rtrlxcname, rtrlxcname))
        for path in ("etc/hostname", "etc/hosts", "etc/network/interfaces",
                     "etc/quagga/bgpd.conf", "etc/quagga/zebra.conf"):
            fd.write("lxc.mount.entry = /internet/%s/%s %s none bind\n"
                     % (rtrlxcname, path, path))

        fd.write("""
# Auto-start
lxc.start.auto = 1
lxc.group = routers

# Network configuration
""")

        for link in get_links(cur, rtrlxcname, True):
            fd.write("""lxc.network.type = phys
lxc.network.flags = up
lxc.network.name = %s
lxc.network.link = %s
lxc.network.hwaddr = %s

""" % (link['iface'], link['iface'], link['mac_left']))


def gen_config(database, target, startgroup=0):
    cur = database.cursor()
    cur.execute("select * from router")
    rtrs = cur.fetchall()
    if not rtrs:
        sys.exit(1)

    # id, name, gps, fqdn, lxcname, asn, internal, tier, prefix32, required
    for rtr in rtrs:
        rtrid = rtr[0]
        rtrlxcname = rtr[4]
        rtrasn = rtr[5]
        rtrtier = rtr[7]
        rtrprefix = rtr[8].split("/")[0][0:9]
        rtrfqdn = rtr[3]

        if rtrtier == 4:
            continue
        try:
            shutil.rmtree("%s/%s" % (target, rtrlxcname))
        except:
            pass
        os.mkdir("%s/%s" % (target, rtrlxcname))
        os.mkdir("%s/%s/overlay/" % (target, rtrlxcname))
        os.mkdir("%s/%s/etc/" % (target, rtrlxcname))
        gen_zebra(rtrlxcname, target)
        gen_bgpd(cur, rtrlxcname, rtrid, rtrasn, target)
        if rtrlxcname != "legacy":
            gen_interfaces(cur, rtrlxcname, rtrid, rtrprefix, rtrtier,
                           rtrfqdn, target)
            gen_hosts(rtrlxcname, target)
            gen_hostname(rtrlxcname, target)
            gen_lxc_config(cur, rtrlxcname, target)


def gen_dnsmasq(database, target):
    cur = database.cursor()
    cur.execute("select * from dns")
    records = cur.fetchall()

    with open("%s/dnsmasq.conf" % target, "w+") as fd:
        fd.write("no-hosts\n")
        fd.write("bind-interfaces\n")
        fd.write("pid-file=/internet/dnsmasq.pid\n")
        fd.write("listen-address=9000::1\n")
        fd.write("cache-size=0\n")
        fd.write("proxy-dnssec\n")
        fd.write("server=8.8.8.8\n")
        fd.write("server=8.8.4.4\n")
        fd.write("server=2001:4860:4860::8888\n")
        fd.write("server=2001:4860:4860::8844\n")

        if records:
            for record in records:
                fd.write("address=/%s./%s\n" % (record[1], record[0]))
                rdns = netaddr.IPAddress(record[0]).reverse_dns
                fd.write("ptr-record=%s,%s.\n" % (rdns, record[1]))

        cur.execute("select * from router")
        records = cur.fetchall()

        if records:
            for record in records:
                rtrid = record[0]
                rtrfqdn = record[3]
                rtrprefix = record[8].split("/")[0][0:9]

                if not rtrfqdn or not rtrprefix:
                    continue

                random.seed(rtrid)
                strprefix = "%s:%s:%s:%s:%s:%s" % (
                    rtrprefix, "dead:beef", random.randint(0, 4095),
                    random.randint(0, 4095), random.randint(0, 4095),
                    random.randint(0, 4095))
                ipv6 = str(netaddr.ip.IPAddress(strprefix).ipv6())

                fd.write("address=/%s./%s\n" % (rtrfqdn, ipv6))
                rdns = netaddr.IPAddress(ipv6).reverse_dns
                fd.write("ptr-record=%s,%s.\n" % (rdns, rtrfqdn))


def create_interfaces(database):
    cur = database.cursor()
    cur.execute("select id from links")
    links = cur.fetchall()
    if not links:
        return

    # Container interfaces
    for (linkid,) in links:
        # Remove existing interfaces
        if os.path.exists("/sys/class/net/veth-%s-1" % linkid):
            if subprocess.call(['ip', 'link', 'del', 'dev',
                                'veth-%s-1' % linkid]) != 0:
                raise Error("Failed to destroy interface: %s" % linkid)

        # Then create it from scratch
        if subprocess.call(['ip', 'link', 'add', 'name', 'veth-%s-1' % linkid,
                            'type', 'veth', 'peer', 'name',
                            'veth-%s-2' % linkid]) != 0:
            raise Error("Failed to create interfaces for link: %s" % linkid)

    # Host side interfaces
    for link in get_links(cur, "legacy", True):
        if subprocess.call(['ip', 'link', 'set', 'dev', link['iface'],
                            'address', link['mac_left']]) != 0:
            raise Error("Failed to set MAC for link: %s" % link['iface'])

        if subprocess.call(['ip', 'link', 'set', 'dev', link['iface'],
                            'up']) != 0:
            raise Error("Failed to bring link up: %s" % link['iface'])


def execute(container, cmd, cwd="/"):
    def run_command(args):
        cmd, cwd = args

        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        return subprocess.call(cmd, cwd=cwd)

    if isinstance(cmd, str):
        rootfs = container.get_config_item("lxc.rootfs")
        cmdpath = "%s/tmp/exec_script" % rootfs
        with open(cmdpath, "w+") as fd:
            fd.write(cmd)
        os.chmod(cmdpath, 0o755)
        cmd = ["/tmp/exec_script"]

    print(" ==> Executing: \"%s\" in %s" % (" ".join(cmd), cwd))
    retval = container.attach_wait(run_command,
                                   (cmd, cwd),
                                   env_policy=lxc.LXC_ATTACH_CLEAR_ENV)

    if retval != 0:
        raise Error("Failed to run the command.")


def start(container):
    container.start()

    ips = container.get_ips(timeout=30, family="inet")
    if not ips:
        raise Error("No IP address after 30s.")


def create_container(args):
    container = lxc.Container(args.name)

    if container.defined:
        raise Error("Container '%s' already exists." % args.name)

    print(" ==> Creating container: %s" % args.name)
    container.create("download", 0, {'dist': "ubuntu",
                                     'release': "trusty",
                                     'arch': "amd64"})

    print(" ==> Configuring the container")
    container.set_config_item("lxc.aa_profile", "unconfined")
    container.append_config_item("lxc.mount.auto", "cgroup:mixed")
    container.save_config()

    print(" ==> Starting the container")
    start(container)

    print(" ==> Installing the required packages")
    execute(container, ["apt-get", "update"])
    execute(container, ["apt-get", "dist-upgrade", "-y"])
    execute(container, ["apt-get", "install", "bind9-host", "dnsmasq-base",
                        "iputils-tracepath", "lxc", "mtr-tiny",
                        "quagga", "tcpdump", "-y"])

    execute(container, ["ln", "-s", "/internet/legacy/etc/quagga/bgpd.conf",
                        "/etc/quagga/bgpd.conf"])
    execute(container, ["ln", "-s", "/internet/legacy/etc/quagga/zebra.conf",
                        "/etc/quagga/zebra.conf"])
    execute(container, ["sed", "-i", "s/zebra=no/zebra=yes/",
                        "/etc/quagga/daemons"])
    execute(container, ["sed", "-i", "s/bgpd=no/bgpd=yes/",
                        "/etc/quagga/daemons"])

    def create_sub_container():
        print(" ==> Creating a router template sub-container")
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        sub_container = lxc.Container("tpl-router", "/var/lib/lxc/")
        sub_container.load_config("/etc/lxc/default.conf")
        sub_container.create("download", 0, {'dist': "ubuntu",
                                             'release': "trusty",
                                             'arch': "amd64"})

        print(" ==> Starting the sub-container")
        start(sub_container)

        print(" ==> Installing the required packages")
        execute(sub_container, ["apt-get", "update"])
        execute(sub_container, ["apt-get", "dist-upgrade", "-y"])
        execute(sub_container, ["apt-get", "install", "bind9-host",
                                "iputils-tracepath", "mtr-tiny",
                                "quagga", "tcpdump", "-y"])

        # Configure quagga
        print(" ==> Configuring quagga")
        execute(sub_container, ["sed", "-i", "s/zebra=no/zebra=yes/",
                                "/etc/quagga/daemons"])
        execute(sub_container, ["sed", "-i", "s/bgpd=no/bgpd=yes/",
                                "/etc/quagga/daemons"])
        execute(sub_container, ["touch", "/etc/quagga/bgpd.conf"])
        execute(sub_container, ["touch", "/etc/quagga/zebra.conf"])

        print(" ==> Disable unneeded services")
        rootfs = sub_container.get_config_item("lxc.rootfs")
        for service in ("console", "tty1", "tty2", "tty3", "tty4",
                        "cron", "ssh", "upstart-socket-bridge",
                        "upstart-file-bridge", "rsyslog"):
            with open("%s/etc/init/%s.override" %
                      (rootfs, service), "w+") as fd:
                fd.write("manual\n")

        print(" ==> Setting up DNS")
        execute(sub_container, """#!/bin/sh -ex
echo nameserver 9000::1 > /etc/resolvconf/resolv.conf.d/tail
""")

        # Stop the container
        print(" ==> Stopping the sub-container")
        sub_container.stop()

    container.attach_wait(create_sub_container,
                          env_policy=lxc.LXC_ATTACH_CLEAR_ENV)


def destroy_container(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if container.running:
        print(" ==> Stopping the container")
        container.stop()

    print(" ==> Destroying container: %s" % args.name)
    container.destroy()


def update_container(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if not container.running:
        print(" ==> Starting the container")
        start(container)

    print(" ==> Updating the container")
    execute(container, ["apt-get", "update"])
    execute(container, ["apt-get", "dist-upgrade", "-y"])

    def update_sub_container():
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        sub_container = lxc.Container("tpl-router", "/var/lib/lxc/")

        if not sub_container.defined:
            raise Error("Sub-container '%s' doesn't exist." % args.name)

        if not sub_container.running:
            print(" ==> Starting the router template sub-container")
            start(sub_container)

        print(" ==> Updating the router template sub-container")
        execute(sub_container, ["apt-get", "update"])
        execute(sub_container, ["apt-get", "dist-upgrade", "-y"])

        # Stop the container
        print(" ==> Stopping the sub-container")
        sub_container.stop()

    container.attach_wait(update_sub_container,
                          env_policy=lxc.LXC_ATTACH_CLEAR_ENV)


def start_simulation(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if not container.running:
        print(" ==> Starting the container")
        start(container)

    project_path = os.path.join("input", args.project)
    if not os.path.exists(project_path):
        raise Error("Project '%s' doesn't exist." % args.project)

    print(" ==> Loading project: %s" % args.project)
    database = InternetDB(project_path)
    database.init_tables(args.level)

    def project_config():
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        # Kill all containers
        print(" ==> Stopping any running container")
        for router in lxc.list_containers(config_path="/internet",
                                          as_object=True):
            router.stop()

        # Kill dnsmasq
        if os.path.exists("/internet/dnsmasq.pid"):
            print(" ==> Stopping the DNS server")
            with open("/internet/dnsmasq.pid", "r") as fd:
                try:
                    os.kill(int(fd.read().strip()), 9)
                except:
                    pass

        # Remove all config
        if os.path.exists("/internet"):
            print(" ==> Flushing existing configuration")
            shutil.rmtree("/internet")
        os.mkdir("/internet")

        # Generate the config
        print(" ==> Generating new configuration")
        gen_config(database.con, "/internet")
        gen_dnsmasq(database.con, "/internet")

        # Create the interfaces
        print(" ==> Creating the veth interfaces")
        create_interfaces(database.con)

    # Setup the configuration
    container.attach_wait(project_config,
                          env_policy=lxc.LXC_ATTACH_CLEAR_ENV)

    # Setup the host IPv6 address
    print(" ==> Setting up networking")
    execute(container, """#!/bin/sh -ex
ip -6 addr del 9000::1/128 dev lo 2>/dev/null || true
ip -6 addr add 9000::1/128 dev lo
""")

    # Start dnsmasq
    print(" ==> Starting DNS server")
    execute(container, ["dnsmasq", "-C", "/internet/dnsmasq.conf"])

    execute(container, """#!/bin/sh -ex
rm -f /run/resolvconf/interface/eth0.dhclient
echo nameserver 9000::1 > /run/resolvconf/interface/the-internet
resolvconf -u
""")

    # Restart quagga
    print(" ==> Restarting BGP")
    execute(container, ["/etc/init.d/quagga", "restart"])

    # Start the routers
    print(" ==> Starting the routers")
    execute(container, ["lxc-autostart", "-P", "/internet", "-g", "routers"])


def stop_container(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if container.running:
        print(" ==> Stopping the container")
        container.stop()


def show_map(args):
    project_path = os.path.join("input", args.project)
    if not os.path.exists(project_path):
        raise Error("Project '%s' doesn't exist." % args.project)

    database = InternetDB(project_path)
    database.init_tables(args.level)

    cur = database.con.cursor()
    cur.execute("SELECT name, gps, lxcname, fqdn, tier, asn FROM router")
    routers = cur.fetchall()

    cur.execute("SELECT id, left, right FROM links")
    links = cur.fetchall()

    if not routers or not links:
        raise Error("Nothing to render on the map")

    with open("map/routers.js", "w+") as fd:
        for router in routers:
            name = router[0].replace("'", "\\'")
            gps = router[1].replace("/", " ").strip().split()
            lxcname = router[2].replace("-", "_")
            fqdn = router[3]
            tier = router[4]
            asn = router[5]
            coord_name = "%s_coord" % lxcname
            marker_name = "%s_marker" % lxcname

            if tier == 0:
                icon = "tier0Icon"
            elif tier == 1:
                icon = "tier1Icon"
            elif tier == 2:
                icon = "tier2Icon"
            elif tier == 3:
                icon = "tier3Icon"
            else:
                icon = "routerIcon"

            fd.write("""
var %s = [%s, %s];
var %s = L.marker(%s, {icon: %s}).addTo(map);
""" % (coord_name, gps[0], gps[1], marker_name, coord_name, icon))

            fd.write("""
%s.on('mousedown', function(e) {
    var popup = L.popup()
        .setLatLng(e.latlng)
        .setContent('%s<br/>%s<br/>Tier %s<br/>AS: %s')
        .openOn(map);
});
""" % (marker_name, name, fqdn, tier, asn))

        for link in links:
            id_r = link[0]
            left = link[1].replace("-", "_")
            right = link[2].replace("-", "_")

            fd.write("""
var line%s = [%s_coord, %s_coord]
L.polyline(line%s, {color: 'blue', weight: 1}).addTo(map);
""" % (id_r, left, right, id_r))

    # open it
    webbrowser.open("map/index.html")


def list_routers(args):
    project_path = os.path.join("input", args.project)
    if not os.path.exists(project_path):
        raise Error("Project '%s' doesn't exist." % args.project)

    database = InternetDB(project_path)
    database.init_tables(args.level)

    cur = database.con.cursor()
    cur.execute("SELECT name, gps, lxcname, fqdn, tier, asn FROM router")
    routers = cur.fetchall()

    for router in sorted(routers, key=lambda router: router[2]):
        if router[4] == 0:
            continue

        print(" - %s (%s)" % (router[2], router[3]))


def shell_router(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if not container.running:
        raise Error("Container '%s' isn't running." % args.name)

    def spawn_shell():
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        subprocess.call(["/bin/bash"])

    if not args.router:
        container.attach_wait(spawn_shell)
        return

    def attach_sub_container():
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        sub_container = lxc.Container(args.router, "/internet/")

        if not sub_container.defined:
            raise Error("Sub-container '%s' doesn't exist." % args.router)

        if not sub_container.running:
            raise Error("Sub-container '%s' isn't running." % args.router)

        sub_container.attach_wait(spawn_shell)

    container.attach_wait(attach_sub_container)


parser = argparse.ArgumentParser(description="Internet generator")
subparsers = parser.add_subparsers()

# create
parser_create = subparsers.add_parser("create", help="Create a new Internet")
parser_create.add_argument("--name", "-n", metavar="NAME", dest="name",
                           default="the-internet")
parser_create.set_defaults(func=create_container)

# destroy
parser_destroy = subparsers.add_parser("destroy", help="Destroy the Internet")
parser_destroy.add_argument("--name", "-n", metavar="NAME", dest="name",
                            default="the-internet")
parser_destroy.set_defaults(func=destroy_container)

# list-routers
parser_map = subparsers.add_parser("list-routers",
                                   help="Show a list of routers")
parser_map.add_argument("--project", "-p", metavar="PROJECT", dest="project",
                        default="NorthSec 2014")
parser_map.add_argument("--level", "-l", metavar="LEVEL", dest="level",
                        default=None, type=int, help="Max start level")
parser_map.set_defaults(func=list_routers)

# map
parser_map = subparsers.add_parser("map", help="Show a map of a project")
parser_map.add_argument("--project", "-p", metavar="PROJECT", dest="project",
                        default="NorthSec 2014")
parser_map.add_argument("--level", "-l", metavar="LEVEL", dest="level",
                        default=None, type=int, help="Max start level")
parser_map.set_defaults(func=show_map)

# shell
parser_shell = subparsers.add_parser("shell",
                                     help="Show a list of routers")
parser_shell.add_argument("--name", "-n", metavar="NAME", dest="name",
                          default="the-internet")
parser_shell.add_argument("router", metavar="ROUTER", default=None, nargs="?")
parser_shell.set_defaults(func=shell_router)

# start
parser_start = subparsers.add_parser("start", help="Start the simulation")
parser_start.add_argument("--name", "-n", metavar="NAME", dest="name",
                          default="the-internet")
parser_start.add_argument("--project", "-p", metavar="PROJECT", dest="project",
                          default="NorthSec 2014")
parser_start.add_argument("--level", "-l", metavar="LEVEL", dest="level",
                          default=None, type=int, help="Max start level")
parser_start.set_defaults(func=start_simulation)

# stop
parser_stop = subparsers.add_parser("stop", help="Kill the Internet")
parser_stop.add_argument("--name", "-n", metavar="NAME", dest="name",
                         default="the-internet")
parser_stop.set_defaults(func=stop_container)

# update
parser_update = subparsers.add_parser("update", help="Update the Internet")
parser_update.add_argument("--name", "-n", metavar="NAME", dest="name",
                           default="the-internet")
parser_update.set_defaults(func=update_container)

args = parser.parse_args()

if not hasattr(args, "func"):
    parser.print_help()
    sys.exit(1)

try:
    args.func(args)
except Error as e:
    parser.error(e)
