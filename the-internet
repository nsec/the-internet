#!/usr/bin/env python3

import argparse
import csv
import lxc
import math
import netaddr
import os
import random
import shutil
import sqlite3
import subprocess
import sys
import time
import webbrowser


class InternetDB():
    def __init__(self, project_path):
        self.con = sqlite3.connect(':memory:')
        self.project_path = project_path

    def init_tables(self, level):
        cur = self.con.cursor()
        cur.execute("DROP TABLE IF EXISTS router")
        cur.execute("CREATE TABLE router (id INT, name TEXT, gps TEXT, "
                    "fqdn TEXT, lxcname TEXT, asn INT, internal INT, "
                    "tier INT, prefix TEXT)")
        self.read_routers_csv(cur, level)

        cur.execute("DROP TABLE IF EXISTS links")
        cur.execute("CREATE TABLE links (id INT, left TEXT, right TEXT, "
                    "mac_left TEXT, mac_right TEXT, left_prio INT, "
                    "right_prio INT, latency REAL, speed INT)")
        self.import_links_csv(cur)

        cur.execute("DROP TABLE IF EXISTS dns")
        cur.execute("CREATE TABLE dns (address TEXT, name TEXT, type TEXT)")
        self.import_dns_csv(cur)

    def dist_latency(self, origin, destination):
        o = origin.split("/")
        lat1 = float(o[0])
        lon1 = float(o[1])
        d = destination.split("/")
        lat2 = float(d[0])
        lon2 = float(d[1])
        # km
        radius = 6371

        dlat = math.radians(lat2 - lat1)
        dlon = math.radians(lon2 - lon1)
        a = math.sin(dlat / 2) * math.sin(dlat / 2) + \
            math.cos(math.radians(lat1)) *\
            math.cos(math.radians(lat2)) * \
            math.sin(dlon / 2) * math.sin(dlon / 2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
        d = radius * c
        # speed of light in optical fiber approx 213 km/s
        # adding 35% for the overhead
        # adding 0.5ms for the transceiver delay
        speed = 139
        return round(d/speed + 0.5, 1)

    def import_links_csv(self, cur):
        with open(os.path.join(self.project_path, "Links.csv"),
                  'r') as csvfile:
            reader = csv.reader(csvfile)
            first = 1
            linkid = 0
            for row in reader:
                # skip first line
                if first == 1:
                    first = 0
                    continue

                # skip empty lines
                if not row or not row[0]:
                    continue

                left = get_router_data(cur, row[0])
                if not left:
                    continue

                right = get_router_data(cur, row[1])
                if not right:
                    continue

                latency = self.dist_latency(left["gps"], right["gps"])

                # csv: Left, Right, Mac Left, Mac Right, Left priority,
                #      Right priority, Speed

                # db: id, left, right, mac_left, mac_right, left_prio,
                #     right_prio, latency, speed
                cur.execute("INSERT INTO links VALUES(?,?,?,?,?,?,?,?,?)",
                            (linkid, row[0], row[1], row[2], row[3], row[4],
                             row[5], latency, row[6]))
                linkid += 1

    def read_routers_csv(self, cur, level):
        routerid = 0
        with open(os.path.join(self.project_path, "Telco.csv"),
                  'r') as csvfile:
            reader = csv.reader(csvfile)
            first = 1
            for row in reader:
                # skip first line
                if first == 1:
                    first = 0
                    continue

                # skip empty lines
                if not row[0]:
                    continue

                if row[8] and level is not None and int(row[8]) > level:
                    continue

                # csv: Name-0, FQDN-1, Lxc-name-2, Tier-3, Prefix-4, ASN-5,
                #      Internal-6, GPS-7

                # db: id, name, gps, fqdn, lxcname, asn, internal, tier, prefix
                cur.execute("INSERT INTO router VALUES(?,?,?,?,?,?,?,?,?)",
                            (routerid, row[0], row[7], row[1], row[2], row[5],
                             row[6], row[3], row[4]))
                routerid += 1

        with open(os.path.join(self.project_path, "Routers.csv"),
                  'r') as csvfile:
            reader = csv.reader(csvfile)
            first = 1
            for row in reader:
                # skip first line
                if first == 1:
                    first = 0
                    continue

                # skip empty lines
                if not row[0]:
                    continue

                # csv: Name-0, Country-1, GPS-2, Prefix-3, FQDN-4, Subnet-5
                #      Lxc-name-6

                # db: id, name, gps, fqdn, lxcname, uplink, asn, internal,
                #     tier, prefix
                cur.execute("INSERT INTO router VALUES(?,?,?,?,?,?,?,?,?)",
                            (routerid, row[0], row[2], row[4], row[6], "",
                             0, 4, row[5]))
                routerid += 1

    def import_dns_csv(self, cur):
        with open(os.path.join(self.project_path, "DNS.csv"), 'r') as csvfile:
            reader = csv.reader(csvfile)
            first = 1
            for row in reader:
                # skip first line
                if first == 1:
                    first = 0
                    continue

                # skip lines with empty or invalid fields
                if not row[0] or not row[1] or row[1][0] == "(":
                    continue

                # csv: address-0, name-1, lxc-name-2, type-3
                # db: address, name, type
                cur.execute("INSERT INTO dns VALUES(?,?,?)",
                            (row[0].strip(), row[1].strip(), row[3].strip()))


class Error(Exception):
    pass


def gen_interfaces(cur, rtrlxcname, rtrid, rtrprefix,
                   rtrtier, rtrfqdn, target):
    try:
        os.mkdir("%s/etc/network/" % (target))
    except FileExistsError:
        pass
    random.seed(rtrid)
    ip = netaddr.ip
    strprefix = "%s:%s:%s:%s:%s:%s" % (
        rtrprefix, "dead:beef", random.randint(0, 4095),
        random.randint(0, 4095), random.randint(0, 4095),
        random.randint(0, 4095))
    ipv6 = str(ip.IPAddress(strprefix).ipv6())

    with open("%s/etc/network/interfaces" %
              (target), "w") as fd:
        fd.write("""auto lo
iface lo inet loopback
    post-up ip -6 addr add dev lo %s/128
    post-up echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
""" % (ipv6))

        for link in get_links(cur, rtrlxcname, True):
            fd.write("""    post-up tc qdisc add dev %s root netem """
                     """delay %sms || true\n""" %
                     (link['iface'], link['latency']))
            fd.write("""    post-up tc qdisc add dev %s root netem """
                     """rate %smbit || true\n""" %
                     (link['iface'], link['speed']))

        for link in get_links(cur, rtrlxcname, True):
            if not link['right_prefix']:
                print("Missing peer for link: %s", link['id'])

            if link['right_tier'] == 4:
                a = netaddr.EUI(link['mac_right'])
                fd.write("""
auto %s
iface %s inet6 manual
    post-up ip -6 route add dev %s %s via %s
""" % (
                    link['iface'], link['iface'], link['iface'],
                    link['right_prefix'], a.ipv6_link_local()))


def gen_zebra(rtrlxcname, target):
    try:
        os.mkdir("%s/etc/quagga/" % (target))
    except FileExistsError:
        pass
    with open("%s/etc/quagga/zebra.conf" % (target), "w") as fd:
        fd.write("""hostname %s
password zebra%s
enable password zebra%s\n""" % (rtrlxcname, random.randint(9999, 99999999),
                                random.randint(9999, 99999999)))


def gen_interfaces_tier4(cur, rtrlxcname, rtrid, rtrprefix,
                         rtrtier, rtrfqdn, target):
    try:
        os.mkdir("%s/etc/network/" % (target))
    except FileExistsError:
        pass
    with open("%s/etc/network/interfaces" %
              (target), "w") as fd:
        fd.write("""auto lo
iface lo inet loopback

""")

        for link in get_links(cur, rtrlxcname, True):
            mac = netaddr.EUI(link["mac_right"])
            ll = str(mac.ipv6_link_local())
            fd.write("""auto %s
iface %s inet6 static
    address FIXME
    netmask FIXME
    gateway %s
""" % (link['iface'], link['iface'], ll))


def get_router_data(cur, name):
    rtr = {}
    cur.execute("select id, name, gps, fqdn, lxcname, asn, internal, tier, "
                "prefix from router where lxcname=:name", {"name": name})
    r = cur.fetchone()
    if not r:
        return None
    rtr["id"], rtr["name"], rtr["gps"], rtr["fqdn"], rtr["lxcname"], \
        rtr["asn"], rtr["internal"], rtr["tier"], rtr["prefix"] = r
    return rtr


def get_links(cur, rtrlxcname, show_all=False):
    linklist = []
    cur.execute("select id,left,right,mac_left,mac_right,left_prio,"
                "right_prio,latency,speed from links where left=:name",
                {"name": rtrlxcname})
    for l in cur.fetchall():
        link = {}
        link["id"], link["left"], link["right"], link["mac_left"], \
            link["mac_right"], link["left_prio"], link["right_prio"], \
            link["latency"], link["speed"] = l
        r = get_router_data(cur, link["right"])
        if r["asn"] != "" or show_all:
            link["right_asn"] = r["asn"]
            link["right_tier"] = r["tier"]
            link["right_prefix"] = r["prefix"]
            link["iface"] = "veth-%s-1" % link["id"]
            linklist.append(link)

    cur.execute("select id,right,left,mac_right,mac_left,right_prio,"
                "left_prio,latency,speed from links where right=:name",
                {"name": rtrlxcname})
    for l in cur.fetchall():
        link = {}
        link["id"], link["right"], link["left"], link["mac_left"], \
            link["mac_right"], link["left_prio"], link["right_prio"], \
            link["latency"], link["speed"] = l
        r = get_router_data(cur, link["left"])
        if r["asn"] != "" or show_all:
            link["right_asn"] = r["asn"]
            link["right_tier"] = r["tier"]
            link["right_prefix"] = r["prefix"]
            link["iface"] = "veth-%s-2" % link["id"]
            linklist.append(link)

    return sorted(linklist, key=lambda link: link['id'])


def gen_bgpd(cur, rtrlxcname, rtrid, rtrasn, target):
    linklist = get_links(cur, rtrlxcname)
    ip = netaddr.ip
    rtridv4 = str(ip.IPAddress(rtrid).ipv4())
    if rtridv4 == "0.0.0.0":
        rtridv4 = "123.123.123.123"

    with open("%s/etc/quagga/bgpd.conf" % (target), "w") as fd:
        fd.write("""hostname %s
password zebra%s

router bgp %s
 bgp router-id %s
 no bgp default ipv4-unicast\n""" % (rtrlxcname,
                                     random.randint(9999, 99999999),
                                     rtrasn, rtridv4))
        weight = 10
        for l in linklist:
            mac = netaddr.EUI(l["mac_right"])
            ll = str(mac.ipv6_link_local())
            l["link-local"] = ll
            fd.write(" neighbor %s remote-as %s\n" % (ll, l["right_asn"]))
            fd.write("! neighbor %s weight %s\n" % (ll, weight))
            fd.write(" neighbor %s interface %s\n\n" % (ll, l["iface"]))
            weight += 10
        fd.write(" address-family ipv6\n")
        for l in linklist:
            fd.write("  neighbor %s activate\n" % l["link-local"])
        fd.write("  redistribute connected\n")
        fd.write("  redistribute kernel\n")
        fd.write(" exit-address-family\n")


def gen_hosts(rtrlxcname, target):
    with open("%s/etc/hosts" % (target), "w") as fd:
        fd.write("""127.0.0.1    localhost
127.0.1.1    %s

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback localhost
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters\n""" % rtrlxcname)


def gen_hostname(rtrlxcname, target):
    with open("%s/etc/hostname" % (target), "w") as fd:
        fd.write("%s\n" % rtrlxcname)


def gen_lxc_config(cur, rtrlxcname, target):
    with open("%s/config" % (target), "w+") as fd:
        fd.write("""# Auto-generated, do not manually edit.

# Distribution configuration
lxc.include = /usr/share/lxc/config/ubuntu.common.conf
lxc.include = /usr/share/lxc/config/ubuntu.userns.conf
lxc.arch = amd64

# Container specific configuration
lxc.rootfs = overlayfs:/var/lib/lxc/tpl-router/rootfs:/internet/%s/overlay/
lxc.utsname = %s

""" % (rtrlxcname, rtrlxcname))
        for path in ("etc/hostname", "etc/hosts", "etc/network/interfaces",
                     "etc/quagga/bgpd.conf", "etc/quagga/zebra.conf"):
            fd.write("lxc.mount.entry = /internet/%s/%s %s none bind\n"
                     % (rtrlxcname, path, path))

        fd.write("""
# Auto-start
lxc.start.auto = 1
lxc.group = routers

# Network configuration
""")

        for link in get_links(cur, rtrlxcname, True):
            fd.write("""lxc.network.type = phys
lxc.network.flags = up
lxc.network.name = %s
lxc.network.link = %s
lxc.network.hwaddr = %s

""" % (link['iface'], link['iface'], link['mac_left']))


def gen_tier4_lxc_config(cur, rtrlxcname, target):
    with open("%s/config" % (target), "w+") as fd:
        fd.write("""# Auto-generated, do not manually edit.

# Distribution configuration
lxc.include = /usr/share/lxc/config/ubuntu.common.conf
lxc.include = /usr/share/lxc/config/ubuntu.userns.conf
lxc.arch = amd64

# Container specific configuration
lxc.utsname = %s
lxc.rootfs = /var/lib/lxc/%s/rootfs

""" % (rtrlxcname, rtrlxcname))
        fd.write("""
# Auto-start
lxc.start.auto = 1
lxc.group = internet

# Network configuration
""")

        for link in get_links(cur, rtrlxcname, True):
            fd.write("""lxc.network.type = phys
lxc.network.flags = up
lxc.network.name = %s
lxc.network.link = %s
lxc.network.hwaddr = %s

""" % (link['iface'], link['iface'], link['mac_left']))


def gen_ctn_lxc_config(cur, rtrlxcname, target):
    with open("%s/config" % (target), "w+") as fd:
        fd.write("""# Auto-generated, do not manually edit.

# Distribution configuration
lxc.include = /usr/share/lxc/config/ubuntu.common.conf
lxc.include = /usr/share/lxc/config/ubuntu.userns.conf
lxc.arch = amd64

# Container specific configuration
lxc.utsname = %s
lxc.rootfs = %s/rootfs

""" % (rtrlxcname, target))
        fd.write("""
# Auto-start
lxc.start.auto = 1
lxc.group = internet

# Network configuration
""")

        for link in get_links(cur, rtrlxcname, True):
            fd.write("""lxc.network.type = phys
lxc.network.flags = up
lxc.network.name = %s
lxc.network.link = %s
lxc.network.hwaddr = %s

""" % (link['iface'], link['iface'], link['mac_left']))


def gen_config(database, target, startgroup=0):
    cur = database.cursor()
    cur.execute("select * from router")
    rtrs = cur.fetchall()
    if not rtrs:
        sys.exit(1)

    # id, name, gps, fqdn, lxcname, asn, internal, tier, prefix32, required
    for rtr in rtrs:
        rtrid = rtr[0]
        rtrlxcname = rtr[4]
        rtrasn = rtr[5]
        rtrtier = rtr[7]
        rtrprefix = rtr[8].split("/")[0][0:9]
        rtrfqdn = rtr[3]

        if rtrtier == 4:
            # Prepare the network configuration for tier 4 machines in /tmp
            # the admin can copy it manually to the containers.
            # In the Links CSV, the tier 4 must be on the right of its uplink.
            try:
                os.mkdir("/tmp/%s" % (rtrlxcname))
            except FileExistsError:
                pass
            try:
                os.mkdir("/tmp/%s/rootfs" % (rtrlxcname))
            except FileExistsError:
                pass
            try:
                os.mkdir("/tmp/%s/rootfs/etc" % (rtrlxcname))
            except FileExistsError:
                pass
            try:
                os.mkdir("/tmp/%s/rootfs/etc/network" % (rtrlxcname))
            except FileExistsError:
                pass

            target_root = "/tmp/%s/rootfs" % (rtrlxcname)
            gen_interfaces_tier4(cur, rtrlxcname, rtrid, rtrprefix, rtrtier,
                                 rtrfqdn, target_root)
            gen_tier4_lxc_config(cur, rtrlxcname, "/tmp/%s" % rtrlxcname)

        elif rtrlxcname.startswith("bgp-"):
            try:
                shutil.rmtree("%s/%s" % (target, rtrlxcname))
            except:
                pass

            target_root = "%s/%s" % (target, rtrlxcname)
            os.mkdir(target_root)
            os.mkdir("%s/overlay/" % (target_root))
            os.mkdir("%s/etc/" % (target_root))
            gen_zebra(rtrlxcname, target_root)
            gen_bgpd(cur, rtrlxcname, rtrid, rtrasn, target_root)
            gen_interfaces(cur, rtrlxcname, rtrid, rtrprefix, rtrtier,
                           rtrfqdn, target_root)
            gen_hosts(rtrlxcname, target_root)
            gen_hostname(rtrlxcname, target_root)
            gen_lxc_config(cur, rtrlxcname, target_root)

        elif rtrlxcname == "legacy":
            try:
                shutil.rmtree("%s/%s" % (target, rtrlxcname))
            except:
                pass

            target_root = "%s/%s" % (target, rtrlxcname)
            os.mkdir(target_root)
            os.mkdir("%s/overlay/" % (target_root))
            os.mkdir("%s/etc/" % (target_root))
            gen_zebra(rtrlxcname, target_root)
            gen_bgpd(cur, rtrlxcname, rtrid, rtrasn, target_root)

        elif rtrlxcname.startswith("ctn-"):
            if not os.path.exists("/var/lib/lxc/%s/config" % rtrlxcname):
                raise Error("User managed router %s doesn't exist."
                            % rtrlxcname)

            target_root = "/var/lib/lxc/%s/rootfs" % (rtrlxcname)
            gen_zebra(rtrlxcname, target_root)
            gen_bgpd(cur, rtrlxcname, rtrid, rtrasn, target_root)
            gen_interfaces(cur, rtrlxcname, rtrid, rtrprefix, rtrtier,
                           rtrfqdn, target_root)
            gen_hosts(rtrlxcname, target_root)
            gen_hostname(rtrlxcname, target_root)
            gen_ctn_lxc_config(cur, rtrlxcname, "/var/lib/lxc/%s" % rtrlxcname)


def gen_dnsmasq(database, target):
    cur = database.cursor()
    cur.execute("select * from dns")
    records = cur.fetchall()

    with open("%s/dnsmasq.conf" % target, "w+") as fd:
        fd.write("no-hosts\n")
        fd.write("bind-interfaces\n")
        fd.write("pid-file=/internet/dnsmasq.pid\n")
        fd.write("listen-address=9000::1\n")
        fd.write("cache-size=0\n")
        fd.write("proxy-dnssec\n")
        fd.write("server=8.8.8.8\n")
        fd.write("server=8.8.4.4\n")
        fd.write("server=2001:4860:4860::8888\n")
        fd.write("server=2001:4860:4860::8844\n")

        if records:
            for record in records:
                # 0: address, 1: name, 2: type
                dnsaddress = record[0]
                dnsname = record[1]
                dnstype = record[2]
                if dnstype == "AAAA":
                    fd.write("address=/%s./%s\n" % (dnsname, dnsaddress))
                    rdns = netaddr.IPAddress(dnsaddress).reverse_dns
                    fd.write("ptr-record=%s,%s.\n" % (rdns, dnsname))
                else:
                    continue

        cur.execute("select * from router")
        records = cur.fetchall()

        if records:
            for record in records:
                rtrid = record[0]
                rtrfqdn = record[3]
                rtrlxcname = record[4]
                rtrtier = record[7]
                rtrprefix = record[8].split("/")[0][0:9]

                if not rtrfqdn or not rtrprefix:
                    continue

                if rtrtier == 4:
                    continue

                random.seed(rtrid)
                strprefix = "%s:%s:%s:%s:%s:%s" % (
                    rtrprefix, "dead:beef", random.randint(0, 4095),
                    random.randint(0, 4095), random.randint(0, 4095),
                    random.randint(0, 4095))
                ipv6 = str(netaddr.ip.IPAddress(strprefix).ipv6())

                if rtrlxcname == "legacy":
                    ipv6 = "9000::1"

                fd.write("address=/%s./%s\n" % (rtrfqdn, ipv6))
                rdns = netaddr.IPAddress(ipv6).reverse_dns
                fd.write("ptr-record=%s,%s.\n" % (rdns, rtrfqdn))


def create_interfaces(database):
    cur = database.cursor()
    cur.execute("select id from links")
    links = cur.fetchall()
    if not links:
        return

    # Container interfaces
    for (linkid,) in links:
        # Remove existing interfaces
        if os.path.exists("/sys/class/net/veth-%s-1" % linkid):
            if subprocess.call(['ip', 'link', 'del', 'dev',
                                'veth-%s-1' % linkid]) != 0:
                raise Error("Failed to destroy interface: %s" % linkid)

        # Then create it from scratch
        if subprocess.call(['ip', 'link', 'add', 'name', 'veth-%s-1' % linkid,
                            'type', 'veth', 'peer', 'name',
                            'veth-%s-2' % linkid]) != 0:
            raise Error("Failed to create interfaces for link: %s" % linkid)

    # Host side interfaces
    for link in get_links(cur, "legacy", True):
        if subprocess.call(['ip', 'link', 'set', 'dev', link['iface'],
                            'address', link['mac_left']]) != 0:
            raise Error("Failed to set MAC for link: %s" % link['iface'])

        if subprocess.call(['ip', 'link', 'set', 'dev', link['iface'],
                            'up']) != 0:
            raise Error("Failed to bring link up: %s" % link['iface'])


def execute(container, cmd, cwd="/", stdin=sys.stdin, ignore_failure=False):
    def run_command(args):
        cmd, cwd = args

        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        return subprocess.call(cmd, cwd=cwd)

    if isinstance(cmd, str):
        rootfs = container.get_config_item("lxc.rootfs")
        cmdpath = "%s/tmp/exec_script" % rootfs
        with open(cmdpath, "w+") as fd:
            fd.write(cmd)
        os.chmod(cmdpath, 0o755)
        cmd = ["/tmp/exec_script"]

    print(" ==> Executing: \"%s\" in %s" % (" ".join(cmd), cwd))
    retval = container.attach_wait(run_command,
                                   (cmd, cwd),
                                   env_policy=lxc.LXC_ATTACH_CLEAR_ENV,
                                   stdin=stdin)

    if retval != 0 and not ignore_failure:
        raise Error("Failed to run the command.")


def start(container):
    container.start()

    ips = container.get_ips(timeout=30)
    if not ips:
        raise Error("No IP address after 30s.")

    # Once we have an IP, leave some time for DNS config
    time.sleep(5)


def create_container(args):
    container = lxc.Container(args.name)

    if container.defined:
        raise Error("Container '%s' already exists." % args.name)

    if args.config:
        print(" ==> Loading user configuration")
        container.load_config(os.path.expanduser(args.config))

    print(" ==> Creating container: %s" % args.name)
    container.create("download", 0, {'dist': "ubuntu",
                                     'release': "trusty",
                                     'arch': "amd64"})

    if args.btrfs:
        rootfs = container.get_config_item("lxc.rootfs")
        stat = os.stat(rootfs)
        cmd = ["lxc-usernsexec",
               "-m", "u:0:%s:1" % os.geteuid(),
               "-m", "g:0:%s:1" % os.getegid(),
               "-m", "u:1:%s:65536" % stat.st_uid,
               "-m", "g:1:%s:65536" % stat.st_gid,
               "/bin/sh"]

        with open(os.devnull, "w") as devnull:
            btrfs = subprocess.Popen(cmd,
                                     stdin=subprocess.PIPE,
                                     stdout=devnull,
                                     stderr=devnull,
                                     universal_newlines=True)

            btrfs.stdin.write("mv %s %s.orig\n" % (rootfs, rootfs))
            btrfs.stdin.write("btrfs subvolume create %s\n" % rootfs)
            btrfs.stdin.write("chown 1:1 %s\n" % rootfs)
            btrfs.stdin.write("cp -R --reflink %s.orig/* %s/\n" %
                              (rootfs, rootfs))
            btrfs.stdin.write("rm -Rf %s.orig\n" % rootfs)
            btrfs.stdin.close()

            if btrfs.wait() != 0:
                raise Error("Failed to setup btrfs")

    print(" ==> Configuring the container")
    container.set_config_item("lxc.aa_profile", "unconfined")
    container.set_config_item("lxc.tty", "0")
    container.append_config_item("lxc.mount.auto", "cgroup:mixed")
    container.save_config()

    if args.static_network:
        fields = args.static_network.split(",")
        if len(fields) < 5:
            raise Error("Wrong static network configuration")

        net_family = fields[0]
        net_addr = fields[1]
        net_mask = fields[2]
        net_gw = fields[3]
        net_dns = fields[4:]

        def configure_network():
            print(" ==> Configuring static networking")
            with open("/etc/network/interfaces", "w+") as fd:
                fd.write("# This file describes the network interfaces "
                         "available on your system" """
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

auto eth0
iface eth0 %s static
    address %s
    netmask %s
    gateway %s
    dns-nameservers %s
""" % (net_family, net_addr, net_mask, net_gw, " ".join(net_dns)))

        container.start()
        container.attach_wait(configure_network,
                              env_policy=lxc.LXC_ATTACH_CLEAR_ENV)
        container.stop()

    print(" ==> Starting the container")
    start(container)

    print(" ==> Installing the required packages")
    execute(container, ["apt-get", "update"])
    execute(container, ["apt-get", "dist-upgrade", "-y"])
    execute(container, ["apt-get", "install", "apache2", "bind9-host",
                        "dnsmasq-base", "iputils-tracepath", "lxc", "mtr-tiny",
                        "quagga", "tcpdump", "-y"])

    if args.daily:
        execute(container, ["apt-get", "install",
                            "software-properties-common", "-y"])
        execute(container, ["apt-add-repository",
                            "ppa:ubuntu-lxc/daily", "-y"])
        execute(container, ["apt-get", "update"])
        execute(container, ["apt-get", "dist-upgrade", "-y"])

    execute(container, ["ln", "-s", "/internet/legacy/etc/quagga/bgpd.conf",
                        "/etc/quagga/bgpd.conf"])
    execute(container, ["ln", "-s", "/internet/legacy/etc/quagga/zebra.conf",
                        "/etc/quagga/zebra.conf"])
    execute(container, ["sed", "-i", "s/zebra=no/zebra=yes/",
                        "/etc/quagga/daemons"])
    execute(container, ["sed", "-i", "s/bgpd=no/bgpd=yes/",
                        "/etc/quagga/daemons"])
    execute(container, ["rm", "-Rf", "/var/www/html"])
    execute(container, ["ln", "-s", "/internet/map", "/var/www/html"])
    execute(container, ["stop", "lxc-net"], ignore_failure=True)
    execute(container, ["sed", "-i",
                        "s/USE_LXC_BRIDGE=\"true\"/USE_LXC_BRIDGE=\"false\"/",
                        "/etc/default/lxc-net"])
    execute(container, ["start", "lxc-net"])

    def disable_services():
        for service in ("console", "tty1", "tty2", "tty3", "tty4",
                        "upstart-socket-bridge",
                        "upstart-file-bridge"):
            with open("/etc/init/%s.override" % service, "w+") as fd:
                fd.write("manual\n")
    print(" ==> Disable unneeded services")
    container.attach_wait(disable_services,
                          env_policy=lxc.LXC_ATTACH_CLEAR_ENV)

    def create_sub_container():
        print(" ==> Creating a router template sub-container")
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        sub_container = lxc.Container("tpl-router", "/var/lib/lxc/")
        sub_container.set_config_item("lxc.network.0.type", "none")
        sub_container.set_config_item("lxc.tty", "0")
        sub_container.append_config_item(
            "lxc.mount.entry",
            "/run/resolvconf/resolv.conf etc/resolv.conf none bind,ro")
        sub_container.create("download", 0, {'dist': "ubuntu",
                                             'release': "trusty",
                                             'arch': "amd64"})
        sub_container.save_config()

        print(" ==> Starting the sub-container")
        start(sub_container)

        print(" ==> Installing the required packages")
        execute(sub_container, ["apt-get", "update"])
        execute(sub_container, ["apt-get", "dist-upgrade", "-y"])
        execute(sub_container, ["apt-get", "install", "bind9-host",
                                "iputils-tracepath", "mtr-tiny",
                                "quagga", "tcpdump", "-y"])

        # Configure quagga
        print(" ==> Configuring quagga")
        execute(sub_container, ["sed", "-i", "s/zebra=no/zebra=yes/",
                                "/etc/quagga/daemons"])
        execute(sub_container, ["sed", "-i", "s/bgpd=no/bgpd=yes/",
                                "/etc/quagga/daemons"])
        execute(sub_container, ["touch", "/etc/quagga/bgpd.conf"])
        execute(sub_container, ["touch", "/etc/quagga/zebra.conf"])

        print(" ==> Disable unneeded services")
        rootfs = sub_container.get_config_item("lxc.rootfs")
        for service in ("console", "tty1", "tty2", "tty3", "tty4",
                        "cron", "upstart-socket-bridge",
                        "upstart-file-bridge", "rsyslog"):
            with open("%s/etc/init/%s.override" %
                      (rootfs, service), "w+") as fd:
                fd.write("manual\n")

        print(" ==> Setting up DNS")
        execute(sub_container, """#!/bin/sh -ex
echo nameserver 9000::1 > /etc/resolvconf/resolv.conf.d/tail
""")

        # Stop the container
        print(" ==> Stopping the sub-container")
        sub_container.stop()

    container.attach_wait(create_sub_container,
                          env_policy=lxc.LXC_ATTACH_CLEAR_ENV)

    print(" ==> Restarting the container")
    container.stop()
    container.start()


def destroy_container(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if container.running:
        print(" ==> Stopping the container")
        container.stop()

    print(" ==> Destroying container: %s" % args.name)
    container.destroy()


def update_container(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if not container.running:
        print(" ==> Starting the container")
        start(container)

    print(" ==> Updating the container")
    execute(container, ["apt-get", "update"])
    execute(container, ["apt-get", "dist-upgrade", "-y"])

    def update_sub_container():
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        sub_container = lxc.Container("tpl-router", "/var/lib/lxc/")

        if not sub_container.defined:
            raise Error("Sub-container '%s' doesn't exist." % args.name)

        if not sub_container.running:
            print(" ==> Starting the router template sub-container")
            start(sub_container)

        print(" ==> Updating the router template sub-container")
        execute(sub_container, ["apt-get", "update"])
        execute(sub_container, ["apt-get", "dist-upgrade", "-y"])

        # Stop the container
        print(" ==> Stopping the sub-container")
        sub_container.stop()

    container.attach_wait(update_sub_container,
                          env_policy=lxc.LXC_ATTACH_CLEAR_ENV)


def start_simulation(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if not os.path.exists("/proc/net/ip6_tables_names"):
        print(" ==> Required IPv6 kernel modules seems missing on the host")
        print("Running \"modprobe ip6_tables\" as root "
              "user should solve this problem")
        sys.exit(1)

    if not container.running:
        print(" ==> Starting the container")
        start(container)

    project_path = os.path.join("input", args.project)
    if not os.path.exists(project_path):
        raise Error("Project '%s' doesn't exist." % args.project)

    print(" ==> Loading project: %s" % args.project)
    database = InternetDB(project_path)
    database.init_tables(args.level)

    def project_config():
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        # Kill all containers
        print(" ==> Stopping any running routers")
        for router in lxc.list_containers(config_path="/internet",
                                          as_object=True):
            router.stop()

        print(" ==> Stopping any running container")
        for router in lxc.list_containers(config_path="/var/lib/lxc",
                                          as_object=True):
            router.stop()

        # Kill dnsmasq
        if os.path.exists("/internet/dnsmasq.pid"):
            print(" ==> Stopping the DNS server")
            with open("/internet/dnsmasq.pid", "r") as fd:
                try:
                    os.kill(int(fd.read().strip()), 9)
                except:
                    pass

        # Remove all config
        if os.path.exists("/internet"):
            print(" ==> Flushing existing configuration")
            shutil.rmtree("/internet")
        os.mkdir("/internet")

        # Generate the config
        print(" ==> Generating new configuration")
        gen_config(database.con, "/internet")
        gen_dnsmasq(database.con, "/internet")

        # Create the interfaces
        print(" ==> Creating the veth interfaces")
        create_interfaces(database.con)

    # Setup the configuration
    container.attach_wait(project_config,
                          env_policy=lxc.LXC_ATTACH_CLEAR_ENV)

    # Setup the host IPv6 address
    print(" ==> Setting up networking")
    execute(container, """#!/bin/sh -ex
echo 2 > /proc/sys/net/ipv6/conf/eth0/accept_ra
echo 1 > /proc/sys/net/ipv6/conf/all/forwarding
ifdown eth0
ifup eth0
ip6tables -t nat -D POSTROUTING -o eth0 -j MASQUERADE 2>/dev/null || true
ip6tables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

ip -6 addr del 9000::1/128 dev lo 2>/dev/null || true
ip -6 addr add 9000::1/128 dev lo
""")

    # Start dnsmasq
    print(" ==> Starting DNS server")
    execute(container, ["dnsmasq", "-C", "/internet/dnsmasq.conf"])

    execute(container, """#!/bin/sh -ex
rm -f /run/resolvconf/interface/eth0.dhclient
echo nameserver 9000::1 > /run/resolvconf/interface/00-the-internet
resolvconf -u
""")

    # Restart quagga
    print(" ==> Restarting BGP")
    execute(container, ["/etc/init.d/quagga", "restart"])

    # Copy the map
    print(" ==> Setup web server")
    gen_map(database)
    tar = subprocess.Popen(["tar", "cf", "-", "map",
                            "--owner", "root", "--group", "root"],
                           stdout=subprocess.PIPE, universal_newlines=True)
    execute(container, ["tar", "xf", "-", "-C", "/internet"],
            stdin=tar.stdout)
    tar.wait()
    execute(container, ["chmod", "-R", "000", "/internet/map"])
    execute(container, ["chmod", "-R", "u+rwX,g+rwX,o+rX", "/internet/map"])

    # Start the routers
    print(" ==> Starting the routers")
    execute(container, ["lxc-autostart", "-P", "/internet", "-g", "routers"])

    print(" ==> Starting the other containers")
    execute(container, ["lxc-autostart", "-g", "internet"])


def stop_container(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if container.running:
        print(" ==> Stopping the container")
        container.stop()


def gen_map(database):
    cur = database.con.cursor()
    cur.execute("SELECT name, gps, lxcname, fqdn, tier, asn FROM router")
    routers = cur.fetchall()

    cur.execute("SELECT id, left, right FROM links")
    links = cur.fetchall()

    if not routers or not links:
        raise Error("Nothing to render on the map")

    with open("map/routers.js", "w+") as fd:
        for router in routers:
            name = router[0].replace("'", "\\'")
            gps = router[1].replace("/", " ").strip().split()
            lxcname = router[2].replace("-", "_")
            fqdn = router[3]
            tier = router[4]
            asn = router[5]
            coord_name = "%s_coord" % lxcname
            marker_name = "%s_marker" % lxcname

            if tier == 0:
                icon = "tier0Icon"
            elif tier == 1:
                icon = "tier1Icon"
            elif tier == 2:
                icon = "tier2Icon"
            elif tier == 3:
                icon = "tier3Icon"
            else:
                icon = "routerIcon"

            fd.write("""
var %s = [%s, %s];
var %s = L.marker(%s, {icon: %s}).addTo(map);
""" % (coord_name, gps[0], gps[1], marker_name, coord_name, icon))

            fd.write("""
%s.on('mousedown', function(e) {
    var popup = L.popup()
        .setLatLng(e.latlng)
        .setContent('%s<br/>%s<br/>Tier %s<br/>AS: %s<br/>Container: %s')
        .openOn(map);
});
""" % (marker_name, name, fqdn, tier, asn, router[2]))

        for link in links:
            id_r = link[0]
            left = link[1].replace("-", "_")
            right = link[2].replace("-", "_")

            fd.write("""
var line%s = [%s_coord, %s_coord]
L.polyline(line%s, {color: 'blue', weight: 1}).addTo(map);
""" % (id_r, left, right, id_r))


def show_map(args):
    project_path = os.path.join("input", args.project)
    if not os.path.exists(project_path):
        raise Error("Project '%s' doesn't exist." % args.project)

    database = InternetDB(project_path)
    database.init_tables(args.level)

    gen_map(database)

    # open it
    webbrowser.open("map/index.html")


def list_routers(args):
    project_path = os.path.join("input", args.project)
    if not os.path.exists(project_path):
        raise Error("Project '%s' doesn't exist." % args.project)

    database = InternetDB(project_path)
    database.init_tables(args.level)

    cur = database.con.cursor()
    cur.execute("SELECT name, gps, lxcname, fqdn, tier, asn FROM router")
    routers = cur.fetchall()

    for router in sorted(routers, key=lambda router: router[2]):
        print(" - %s (%s)" % (router[2], router[3]))


def shell_router(args):
    container = lxc.Container(args.name)

    if not container.defined:
        raise Error("Container '%s' doesn't exist." % args.name)

    if not container.running:
        raise Error("Container '%s' isn't running." % args.name)

    def spawn_shell():
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        subprocess.call(["/bin/bash"])

    if not args.router:
        container.attach_wait(spawn_shell)
        return

    def attach_sub_container():
        os.environ['PATH'] = '/usr/sbin:/usr/bin:/sbin:/bin'
        os.environ['HOME'] = '/root'

        sub_container = lxc.Container(args.router, "/internet/")

        if not sub_container.defined:
            raise Error("Sub-container '%s' doesn't exist." % args.router)

        if not sub_container.running:
            raise Error("Sub-container '%s' isn't running." % args.router)

        sub_container.attach_wait(spawn_shell)

    container.attach_wait(attach_sub_container)


parser = argparse.ArgumentParser(description="Internet generator")
subparsers = parser.add_subparsers()

# create
parser_create = subparsers.add_parser("create", help="Create a new Internet")
parser_create.add_argument("--name", "-n", metavar="NAME", dest="name",
                           default="the-internet")
parser_create.add_argument("--use-daily", dest="daily", action="store_true",
                           default=False)
parser_create.add_argument("--btrfs", dest="btrfs", default=False,
                           action="store_true")
parser_create.add_argument("--config", "-f",
                           metavar="CONFIG", dest="config", default=None)
parser_create.add_argument("--static-network",
                           metavar="FAMILY,IP,NETMASK,GATEWAY,DNS",
                           dest="static_network", default=None)
parser_create.set_defaults(func=create_container)

# destroy
parser_destroy = subparsers.add_parser("destroy", help="Destroy the Internet")
parser_destroy.add_argument("--name", "-n", metavar="NAME", dest="name",
                            default="the-internet")
parser_destroy.set_defaults(func=destroy_container)

# list-routers
parser_map = subparsers.add_parser("list-routers",
                                   help="Show a list of routers")
parser_map.add_argument("--project", "-p", metavar="PROJECT", dest="project",
                        default="NorthSec 2014")
parser_map.add_argument("--level", "-l", metavar="LEVEL", dest="level",
                        default=None, type=int, help="Max start level")
parser_map.set_defaults(func=list_routers)

# map
parser_map = subparsers.add_parser("map", help="Show a map of a project")
parser_map.add_argument("--project", "-p", metavar="PROJECT", dest="project",
                        default="NorthSec 2014")
parser_map.add_argument("--level", "-l", metavar="LEVEL", dest="level",
                        default=None, type=int, help="Max start level")
parser_map.set_defaults(func=show_map)

# shell
parser_shell = subparsers.add_parser("shell",
                                     help="Get access to a shell on a router")
parser_shell.add_argument("--name", "-n", metavar="NAME", dest="name",
                          default="the-internet")
parser_shell.add_argument("router", metavar="ROUTER", default=None, nargs="?")
parser_shell.set_defaults(func=shell_router)

# start
parser_start = subparsers.add_parser("start", help="Start the simulation")
parser_start.add_argument("--name", "-n", metavar="NAME", dest="name",
                          default="the-internet")
parser_start.add_argument("--project", "-p", metavar="PROJECT", dest="project",
                          default="NorthSec 2014")
parser_start.add_argument("--level", "-l", metavar="LEVEL", dest="level",
                          default=None, type=int, help="Max start level")
parser_start.set_defaults(func=start_simulation)

# stop
parser_stop = subparsers.add_parser("stop", help="Kill the Internet")
parser_stop.add_argument("--name", "-n", metavar="NAME", dest="name",
                         default="the-internet")
parser_stop.set_defaults(func=stop_container)

# update
parser_update = subparsers.add_parser("update", help="Update the Internet")
parser_update.add_argument("--name", "-n", metavar="NAME", dest="name",
                           default="the-internet")
parser_update.set_defaults(func=update_container)

args = parser.parse_args()

if not hasattr(args, "func"):
    parser.print_help()
    sys.exit(1)

try:
    args.func(args)
except Error as e:
    parser.error(e)
